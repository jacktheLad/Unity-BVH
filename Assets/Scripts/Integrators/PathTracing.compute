#include "Assets/Scripts/Utils/Common.cginc"
#include "Assets/Scripts/Core/Random.cginc"
#include "Assets/Scripts/Core/Camera.cginc"
#include "Assets/Scripts/Core/Material.cginc"
#include "Assets/Scripts/Core/Interaction.cginc"
#include "Assets/Scripts/BVH/SBVH/SBVHTraversal.cginc"

#pragma kernel CSMain

RWTexture2D<float4> Result;

int _SPPS;
float4 _DirectionalLight;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

//-------------------------------------
//- SHADE

float SmoothnessToPhongAlpha(float s)
{
    return pow(1000.0f, s * s);
}

float3 Shade(inout Ray ray, Interaction hit)
{
    // 除非碰到光源，否则路径都在算能量损失，目前而言，光源有且只有天空盒
    if (hit.distance < INFINITY)
    {

        // Calculate chances of diffuse and specular reflection
        hit.albedo = min(1.0f - hit.specular, hit.albedo);
        float specChance = energy(hit.specular);
        float diffChance = energy(hit.albedo);

        // Roulette-select the ray's path
        float roulette = rand();
        if (roulette < specChance)
        {
            // Specular reflection
            ray.origin = hit.position + hit.normal * 0.001f;
            float alpha = SmoothnessToPhongAlpha(hit.smoothness);
            ray.direction = SampleHemisphere(reflect(ray.direction, hit.normal), alpha);
            float f = (alpha + 2) / (alpha + 1);
            ray.energy *= (1.0f / specChance) * hit.specular * sdot(hit.normal, ray.direction, f);
        }
        else if (diffChance > 0 && roulette < specChance + diffChance)
        {
            // Diffuse reflection
            ray.origin = hit.position + hit.normal * 0.001f;
            ray.direction = SampleHemisphere(hit.normal, 1.0f);
            ray.energy *= (1.0f / diffChance) * hit.albedo;
        }
        else
        {
            // Terminate ray
            ray.energy = 0.0f;
        }

        return hit.emission;
    }
    else
    {
        // Erase the ray's energy - the sky doesn't reflect anything
        ray.energy = 0.0f;

        // Sample the skybox and write it
        float theta = acos(ray.direction.y) / -PI;
        float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    }
}


//-------------------------------------
//- KERNEL

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // For random number generating
    InitRand(id.xy);
    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);

    // Get a ray for the UVs


    // Trace and shade the ray
    float3 result = float3(0, 0, 0);

    for (int spp = 0; spp < _SPPS; spp++)
    {
        Ray ray = CreateCameraRay(id.xy, width, height);
        float3 acc = 0;
        for (int i = 0; i < 8; i++)
        {
            int hitTriIdx;
            float hitDist = INFINITY;
            float3 triNormal;
            bool anyHit = false;

            Trace(ray.origin, ray.direction, hitTriIdx, hitDist, triNormal, anyHit);

            Interaction hit = CreateInteraction();

            if (hitDist < INFINITY) {
                hit.distance = hitDist;
                hit.position = ray.origin + hitDist * ray.direction;
                hit.normal = normalize(triNormal);
                hit.albedo = 0.4f;
                hit.specular = 0.6f;
                hit.smoothness = 0.6f;
                hit.emission = float3(0.0f, 0.0f, 0.0f);
            }

            //result = normalize(triNormal);
            //result = float3(hitDist > 100000 ? 0 : 1, 0, 0);
            acc += ray.energy * Shade(ray, hit);
           
            if (!any(ray.energy))
                break;
        }
        result += acc / _SPPS;
    }

    result = max(0, min(1, result * 8));
    result = pow(result, 2.2);
    
    Result[id.xy] = float4(result, 1);
}
